package miniJava.SyntacticAnalyzer;
import miniJava.ErrorReporter;

	/**
	 * Parser
	 *
	 * Grammar:
	 *   S ::= E '$'
	 *   E ::= T (opers T)*     
	 *   T ::= num | '(' E ')'
	 */
	

	public class Parser {

		private Scanner scanner;
		private ErrorReporter reporter;
		private Token token;
		private boolean trace = false;

		public Parser(Scanner scanner, ErrorReporter reporter) {
			this.scanner = scanner;
			this.reporter = reporter;
		}


		/**
		 * SyntaxError is used to unwind parse stack when parse fails
		 *
		 */
		class SyntaxError extends Error {
			private static final long serialVersionUID = 1L;	
		}

		/**
		 * start parse
		 */
		public void parse() {
			token = scanner.scan();
			try {
				parseProgram();
			}
			catch (SyntaxError e) { }
		}

		public void parseProgram() throws SyntaxError
		{
			parseClassDec();
			accept(TokenKind.EOT);
		}
		
		public void parseClassDec() throws SyntaxError
		{
			if (token.kind == TokenKind.CLASS_DEC)
			{
				acceptIt();
				parseId();
				parseLBrace();
				parseDeclarators();
			}
		}
		
		public void parseDeclarators()
		{
			if (token.kind == TokenKind.PUBLIC_DEC)
			{
				parsePublicDec();
			}
			
			else if (token.kind == TokenKind.PRIVATE_DEC)
			{
				parsePrivateDec();
			}
			
			else
			{
				// Error
			}
			
			if (token.kind == TokenKind.STATIC_DEC)
			{
				parseStaticDec();
			}
			
			if (token.kind == TokenKind.VOID_DEC)
			{
				parseVoidDec();
			}
			
			else
			{
				parseType();
			}
		}
		
		public void parseStaticDec()
		{
			acceptIt();
		}
		
		public void parseVoidDec()
		{
			acceptIt();
		}
		
		public void parseType()
		{
			
		}
		
		public void parsePublicDec()
		{
			acceptIt();
		}
		
		public void parsePrivateDec()
		{
			acceptIt();
		}
		
		public void parseId()
		{
			if (token.kind == TokenKind.ID)
			{
				acceptIt();
			}
		}
		
		private void parseLBrace()
		{
			if (token.kind == TokenKind.LBRACE)
			{
				acceptIt();
			}
		}
		
		void parseClassDec(String currentToken)
		{
			if (currentToken.equals("class"))
			{
				parseFieldDec(currentToken);
				parseMethodDec(currentToken);
			}
			
			else
			{
				System.out.println("ClassDecError");
			}
		}
		
		void parseFieldDec(String currentToken)
		{
			
		}
		
		void parseMethodDec(String currentToken)
		{
			
		}
		
		private void acceptIt() throws SyntaxError {
			accept(token.kind);
		}

		/**
		 * verify that current token in input matches expected token and advance to next token
		 * @param expectedToken
		 * @throws SyntaxError  if match fails
		 */
		private void accept(TokenKind expectedTokenKind) throws SyntaxError {
			if (token.kind == expectedTokenKind) {
				if (trace)
					pTrace();
				token = scanner.scan();
			}
			else
				parseError("expecting '" + expectedTokenKind +
						"' but found '" + token.kind + "'");
		}

		/**
		 * report parse error and unwind call stack to start of parse
		 * @param e  string with error detail
		 * @throws SyntaxError
		 */
		private void parseError(String e) throws SyntaxError {
			reporter.reportError("Parse error: " + e);
			throw new SyntaxError();
		}

		// show parse stack whenever terminal is  accepted
		private void pTrace() {
			StackTraceElement [] stl = Thread.currentThread().getStackTrace();
			for (int i = stl.length - 1; i > 0 ; i--) {
				if(stl[i].toString().contains("parse"))
					System.out.println(stl[i]);
			}
			System.out.println("accepting: " + token.kind + " (\"" + token.spelling + "\")");
			System.out.println();
		}
		
		/*//    S ::= E$
		private void parseS() throws SyntaxError {
			parseE();
			accept(TokenKind.EOT);
		}

		//    E ::= T (("+" | "*") T)*     
		private void parseE() throws SyntaxError {
			parseT();
			while (token.kind == TokenKind.PLUS || token.kind == TokenKind.TIMES) {
				acceptIt();
				parseT();
			} 
		}

		//   T ::= num | "(" E ")"
		private void parseT() throws SyntaxError {
			switch (token.kind) {

			case NUM:
				acceptIt();
				return;

			case LPAREN:
				acceptIt();
				parseE();
				accept(TokenKind.RPAREN);
				return;

			default:
				parseError("Invalid Term - expecting NUM or LPAREN but found " + token.kind);
			}
		}

	*/

	
	
	
}
